.
└── setOwner(address newOwner) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        └── should set owner to newOwner
.
└── enableIrm(IIrm irm) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        └── should set isIrmEnabled[irm] to true
.
└── enableLltv(uint256 lltv) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when lltv >= WAD
        │   └── revert with LLTV_TOO_HIGH
        └── when lltv < WAD
            └── should set isLltvEnabled[lltv] to true
.
└── setFee(Market memory market, uint256 newFee) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when market is not created
        │   └── revert with MARKET_NOT_CREATED
        └── when market is created
            ├── when newFee > MAX_FEE
            │   └── revert with MAX_FEE_EXCEEDED
            └── when newFee <= MAX_FEE
                └── should set fee[id] to newFee
.
└── setFeeRecipient(address recipient) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        └── should set feeRecipient to recipient
.
└── createMarket(Market memory market) external
    ├── when irm is not enabled
    │   └── revert with IRM_NOT_ENABLED
    └── when irm is enabled
        ├── when lltv is not enabled
        │   └── revert with LLTV_NOT_ENABLED
        └── when lltv is enabled
            ├── when market is already created
            │   └── revert with MARKET_CREATED
            └── when market is not already created
                └── it should create market
                    └── it should set lastUpdate[market.id()] to block.timestamp
.
└── supply(Market calldata market, uint256 amount, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to supply is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to supply is not zero
            ├── if data.length > 0
            │   └── sender's onBlueSupply function should be called
            ├── it should accrue the interests
            ├── it should add amount.toSharesDown(totalSupply[id], totalSupplyShares[id]) to supplyShare[id][onBehalf] 
            ├── it should add amount.toSharesDown(totalSupply[id], totalSupplyShares[id]) to totalSupplyShares[id]
            ├── it should add amount to totalSupply[id]
            └── it should transfer amount of the borrowable asset from the sender to Blue
.
└── withdraw(Market memory market, uint256 amount, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to withdraw is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to withdraw is not zero
            ├── when not sender and not approved
            │   └── revert with MANAGER_NOT_APPROVED
            └── when sender or approved
                ├── it should accrue the interests
                ├── when totalBorrow > totalSupply
                │   └── revert with INSUFFICIENT_LIQUIDITY
                └── when totalBorrow <= totalSupply
                    ├── it should remove amount.toSharesUp(totalSupply[id], totalSupplyShares[id]) to supplyShare[id][onBehalf] 
                    ├── it should remove amount.toSharesUp(totalSupply[id], totalSupplyShares[id]) to totalSupplyShares[id]
                    ├── it should remove amount from totalSupply[id]
                    └── it should transfer amount of the borrowable asset to the receiver
.
└── borrow(Market memory market, uint256 amount, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to borrow is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to borrow is not zero
            ├── when not sender and not approved
            │   └── revert with MANAGER_NOT_APPROVED
            └── when sender or approved
                ├── it should accrue the interests
                ├── when position not healthy
                │   └── revert with INSUFFICIENT_COLLATERAL
                └── when position healthy
                    ├── when totalBorrow > totalSupply
                    │   └── revert with INSUFFICIENT_LIQUIDITY
                    └── when totalBorrow <= totalSupply
                        ├── it should add amount.toSharesUp(totalBorrow[id], totalBorrowShares[id]) to borrowShare[id][onBehalf] 
                        ├── it should add amount.toSharesUp(totalBorrow[id], totalBorrowShares[id]) to totalBorrowShares[id]
                        ├── it should add amount to totalBorrow[id]
                        └── it should transfer amount of the borrowable asset to the receiver
.
└── repay(Market memory market, uint256 amount, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to repay is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to repay is not zero
            ├── if data.length > 0
            │   └── sender's onBlueRepayCallback function should be called
            ├── it should accrue the interests
            ├── it should remove amount.toSharesDown(totalBorrow[id], totalBorrowShares[id]) from borrowShare[id][onBehalf]
            ├── it should remove amount.toSharesDown(totalBorrow[id], totalBorrowShares[id]) from totalBorrowShares[id],
            ├── it should remove amount from totalBorrow[id]
            └── it should transfer amount of the borrowable asset from the sender to Blue
.
└── supplyCollateral(Market memory market, uint256 amount, address onBehalf, bytes calldata data) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to supply is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to supply is not zero
            ├── if data.length > 0
            │   └── sender's onBlueSupplyCollateral function should be called
            ├── it should add amount to collateral[id][onBehalf]
            └── it should transfer amount of the collateral asset from the sender to Blue
.
└── withdrawCollateral(Market memory market, uint256 amount, address onBehalf, address receiver) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to withdraw is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to withdraw is not zero
            ├── when not sender and not approved
            │   └── revert with MANAGER_NOT_APPROVED
            └── when sender or approved
                ├── it should accrue the interests
                ├── when position not healthy
                │   └── revert with INSUFFICIENT_COLLATERAL
                └── when position healthy
                    ├── it should remove amount from collateral[id][onBehalf]
                    └── it should transfer amount of the collateral asset to the receiver
.
└── liquidate(Market memory market, address borrower, address onBehalf) external
    ├── when market is not created
    │   └── revert with MARKET_NOT_CREATED
    └── when market is created
        ├── when the amount to seized is zero
        │   └── revert with ZERO_AMOUNT
        └── when the amount to seized is not zero
            ├── it should accrue the interests
            ├── when position is healthy
            │   └── revert with HEALTHY_POSITION
            └── when the position not healthy
                ├── it should compute repaid = seized.mulWadUp(collateralPrice).divWadUp(incentive).divWadUp(borrowablePrice);
                ├── it should remove repaid.toSharesDown(totalBorrow[id], totalBorrowShares[id]) from borrowShare[id][borrower]
                ├── it should remove repaid.toSharesDown(totalBorrow[id], totalBorrowShares[id]) from totalBorrowShares[id]
                ├── it should remove repaid from totalBorrow[id]
                ├── it should remove seized from collateral[id][borrower]
                ├── if after the liquidation the borrower's collateral is 0
                │   └── it should realise bad debt
                │       ├── it should compute badDebt = borrowShare[id][borrower].toAssetsUp(totalBorrow[id], totalBorrowShares[id])
                │       ├── it should remove bad debt from totalSupply[id]
                │       ├── it should remove bad debt from totalBorrow[id]
                │       ├── it should remove borrowShare[id][borrower] from totalBorrowShares[id]
                │       └── it should set borrowShare[id][borrower] to 0
                ├── it should transfer seized of collateral asset to the sender
                └── it should transfer repaid of borrowable asset from the sender the Blue
.
└── flashLoan(IFlashBorrower receiver, address token, uint256 amount, bytes calldata data) external
    ├── when IERC20(token).balanceOf(blue) < amount
    │   └── revert
    └── when IERC20(token).balanceOf(blue) >= amount
        ├── receiver's onBlueFlashLoan should be called
        └── if the safeTransferFrom fails
            └── revert
.
└── setAuthorization(address authorizer, address authorizee, bool newIsAuthorized, uint256 deadline, Signature calldata signature) external
    ├── when block.timestamp >= deadline
    │   └── revert with SIGNATURE_EXPIRED
    └── when block.timestamp < deadline
        ├── when signatory is zero address or signatory is not authorizer
        │   └── revert with INVALID_SIGNATURE
        └── when signatory is authorizer and not zero address
            └── it should set isAuthorized[signatory][authorizee] to newIsAuthorized
.
└── setApproval(address manager, bool isAllowed) external
    └── should set isApproved[msg.sender][manager] to isAllowed
.
└── _accrueInterests(Market memory market, Id id) internal
    └── when interests not already accrued in the block
        ├── it should set lastUpdate to block.timestamp
        └── when marketTotalBorrow is not 0
            ├── it should add accruedInterests to totalBorrow
            ├── it should add accruedInterests to totalSupply
            └── when fee[id] != 0
                ├── it should add accruedInterests.mulWadDown(fee[id]) to feeAmount
                ├── it should add feeAmount.mulDivDown(totalSupplyShares[id], totalSupply[id] - feeAmount) to supplyShare[id][feeRecipient]
                └── it should add feeAmount.mulDivDown(totalSupplyShares[id], totalSupply[id] - feeAmount) to totalSupplyShares[id]
